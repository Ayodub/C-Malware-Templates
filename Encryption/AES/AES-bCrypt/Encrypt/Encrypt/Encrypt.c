#include <Windows.h>
#include <stdio.h>
#include <bcrypt.h>

/* The main drawback of using the bCrypt library is that the usage of the cryptographic WinAPIs results
in them being visible in the binary's import address table (IAT). Security solutions scan the IAT.

Hiding WinAPIs in the IAT is possible in more advanced implementation of this encryption code*/
#pragma comment(lib, "Bcrypt.lib")

//Checks if status >= 0, representing a success (evaluates to TRUE), whereas a negative number would represent an error (evaluates to FALSE).
#define NT_SUCCESS(status) (((NTSTATUS)(status)) >= 0)

#define KEYSIZE 32
#define IVSIZE 16

typedef struct _AES {
	PBYTE pPlainText;  // Base address of plaintext data
	DWORD dwPlainSize; // Size of plaintext data
	PBYTE pCipherText; // Base address of the encrypted data
	DWORD dwCipherSize; // size of the encrypted data
	PBYTE pKey; // 32 byte key
	PBYTE pIv; //16 byte Initialisation vector
} AES, *PAES; // Two aliases are for the _AES struct are declared, the first 'AES' is a simpler name for _AES, while *PAES declares a pointer to the _AES structure called 'PAES'


// generate random bytes of size sSize
VOID GenerateRandomBytes(PBYTE pByte, SIZE_T sSize) {
	for (int i = 0; i < sSize; i++) {
		pByte[i] = (BYTE)rand() % 0xFF; // The modulo (%) operation with 0xFF ensures that the random value is in the range of a byte (0 to 255)
}
	}


// Print the input buffer as a hex char array. 
// For debugging

VOID PrintHexData(LPCSTR Name, PBYTE Data, SIZE_T Size) {
		printf("unsigned char %s[] = {", Name);
		for (int i = 0; i < Size; i++) { // Initiates a loop iterating through each byte in the array
			if (i % 16 == 0) { // Creates a new line and tab every 16 elements. This is simply for readability
				printf("\n\t"); 
			}
			if (i < Size - 1) { // Prints the hexadecimal representation of the current byte
				printf("0x%0.2X, ", Data[i]);
			}
			else {
				printf("0x%0.2X ", Data[i]); // Similar to the last line of code, but handles the final element in the array
			}
		}
		printf("};\n\n\n");
	}


	// The encryption implementation
	BOOL InstallAesEncryption(PAES pAes) {
		BOOL 			bSTATE = TRUE;

		BCRYPT_ALG_HANDLE	hAlgorithm = NULL;
		BCRYPT_KEY_HANDLE	hKeyHandle = NULL;

		ULONG 			cbResult = NULL;
		DWORD 			dwBlockSize = NULL;

		DWORD 			cbKeyObject = NULL;
		PBYTE 			pbKeyObject = NULL;

		PBYTE 			pbCipherText = NULL;
		DWORD 			cbCipherText = NULL,


			// Intializing "hAlgorithm" as AES algorithm Handle
		STATUS = BCryptOpenAlgorithmProvider(&hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0);
		if (!NT_SUCCESS(STATUS)) {
			printf("[!] BCryptOpenAlgorithmProvider Failed With Error: 0x%0.8X \n", STATUS);
			bSTATE = FALSE; goto _EndOfFunc;
		}

		// Getting the size of the key object variable pbKeyObject. This is used by the BCryptGenerateSymmetricKey function later 
		STATUS = BCryptGetProperty(hAlgorithm, BCRYPT_OBJECT_LENGTH, (PBYTE)&cbKeyObject, sizeof(DWORD), &cbResult, 0);
		if (!NT_SUCCESS(STATUS)) {
			printf("[!] BCryptGetProperty[1] Failed With Error: 0x%0.8X \n", STATUS);
			bSTATE = FALSE; goto _EndOfFunc;
		}

		// Getting the size of the block used in the encryption. Since this is AES it must be 16 bytes.
		STATUS = BCryptGetProperty(hAlgorithm, BCRYPT_BLOCK_LENGTH, (PBYTE)&dwBlockSize, sizeof(DWORD), &cbResult, 0);
		if (!NT_SUCCESS(STATUS)) {
			printf("[!] BCryptGetProperty[2] Failed With Error: 0x%0.8X \n", STATUS);
			bSTATE = FALSE; goto _EndOfFunc;
		}

		// Checking if block size is 16 bytes
		if (dwBlockSize != 16) {
			bSTATE = FALSE; goto _EndOfFunc;
		}

		// Allocating memory for the key object 
		pbKeyObject = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbKeyObject);
		if (pbKeyObject == NULL) {
			bSTATE = FALSE; goto _EndOfFunc;
		}

		// Setting Block Cipher Mode to CBC. This uses a 32 byte key and a 16 byte IV.
		STATUS = BCryptSetProperty(hAlgorithm, BCRYPT_CHAINING_MODE, (PBYTE)BCRYPT_CHAIN_MODE_CBC, sizeof(BCRYPT_CHAIN_MODE_CBC), 0);
		if (!NT_SUCCESS(STATUS)) {
			printf("[!] BCryptSetProperty Failed With Error: 0x%0.8X \n", STATUS);
			bSTATE = FALSE; goto _EndOfFunc;
		}

		// Generating the key object from the AES key "pAes->pKey". The output will be saved in pbKeyObject and will be of size cbKeyObject 
		STATUS = BCryptGenerateSymmetricKey(hAlgorithm, &hKeyHandle, pbKeyObject, cbKeyObject, (PBYTE)pAes->pKey, KEYSIZE, 0);
		if (!NT_SUCCESS(STATUS)) {
			printf("[!] BCryptGenerateSymmetricKey Failed With Error: 0x%0.8X \n", STATUS);
			bSTATE = FALSE; goto _EndOfFunc;
		}

		// Running BCryptEncrypt first time with NULL output parameters to retrieve the size of the output buffer which is saved in cbCipherText
		STATUS = BCryptEncrypt(hKeyHandle, (PUCHAR)pAes->pPlainText, (ULONG)pAes->dwPlainSize, NULL, pAes->pIv, IVSIZE, NULL, 0, &cbCipherText, BCRYPT_BLOCK_PADDING);
		if (!NT_SUCCESS(STATUS)) {
			printf("[!] BCryptEncrypt[1] Failed With Error: 0x%0.8X \n", STATUS);
			bSTATE = FALSE; goto _EndOfFunc;
		}

		// Allocating enough memory for the output buffer, cbCipherText
		pbCipherText = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbCipherText);
		if (pbCipherText == NULL) {
			bSTATE = FALSE; goto _EndOfFunc;
		}

		// Running BCryptEncrypt again with pbCipherText as the output buffer
		STATUS = BCryptEncrypt(hKeyHandle, (PUCHAR)pAes->pPlainText, (ULONG)pAes->dwPlainSize, NULL, pAes->pIv, IVSIZE, pbCipherText, cbCipherText, &cbResult, BCRYPT_BLOCK_PADDING);
		if (!NT_SUCCESS(STATUS)) {
			printf("[!] BCryptEncrypt[2] Failed With Error: 0x%0.8X \n", STATUS);
			bSTATE = FALSE; goto _EndOfFunc;
		}



		// Clean up
	_EndOfFunc:
		if (hKeyHandle) {
			BCryptDestroyKey(hKeyHandle);
		}
		if (hAlgorithm) {
			BCryptCloseAlgorithmProvider(hAlgorithm, 0);
		}
		if (pbKeyObject) {
			HeapFree(GetProcessHeap(), 0, pbKeyObject);
		}
		if (pbCipherText != NULL && bSTATE) {
			// If everything worked, save pbCipherText and cbCipherText 
			pAes->pCipherText = pbCipherText;
			pAes->dwCipherSize = cbCipherText;
		}
		return bSTATE;

	}

	

	//wrapper function for InstallAesEncryption that makes things easier
	BOOL SimpleEncryption(IN PVOID pPlainTextData, IN DWORD sPlainTextSize, IN PBYTE pKey, IN PBYTE pIv, OUT PVOID* pCipherTextData, OUT DWORD* sCipherTextSize) {
		if (pPlainTextData == NULL || sPlainTextSize == NULL || pKey == NULL || pIv == NULL)
			return FALSE;

		// Intializing the struct
		AES Aes = {
			.pKey = pKey,
			.pIv = pIv,
			.pPlainText = pPlainTextData,
			.dwPlainSize = sPlainTextSize
		};

		if (!InstallAesEncryption(&Aes)) {
			return FALSE;
		}

		// Saving output
		*pCipherTextData = Aes.pCipherText;
		*sCipherTextSize = Aes.dwCipherSize;

		return TRUE;
	}


	
	//// PLACE PAYLOAD TO BE ENCRYPTED HERE
	//This is a plain text string, we'll try to encrypt/decrypt !" in hex */
	unsigned char Data[] = {
			0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x70, 0x6C,
			0x61, 0x69, 0x6E, 0x20, 0x74, 0x65, 0x78, 0x74, 0x20, 0x73, 0x74, 0x72,
			0x69, 0x6E, 0x67, 0x2C, 0x20, 0x77, 0x65, 0x27, 0x6C, 0x6C, 0x20, 0x74,
			0x72, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x6E, 0x63, 0x72, 0x79, 0x70,
			0x74, 0x2F, 0x64, 0x65, 0x63, 0x72, 0x79, 0x70, 0x74, 0x20, 0x21
	};

	//Encryption main()

	int main() {
		BYTE pKey[KEYSIZE]; //KEYSIZE is 32
		BYTE pIv[IVSIZE]; //IVSIZE is 16

		srand(time(NULL));						// the seed to generate the key
		GenerateRandomBytes(pKey, KEYSIZE);		// generating the key bytes

		srand(time(NULL) ^ pKey[0]);			// the seed to generate the iv (using the first byte from the key to add more spice)
		GenerateRandomBytes(pIv, IVSIZE);		// generating the iv

		// printing both on the screen
		// Save this secret key to be used for decryption
		PrintHexData("pKey", pKey, KEYSIZE);
		PrintHexData("pIv", pIv, IVSIZE);

		//Defining two variables that will be used in SimpleEncryption, the output buffer and its size
		PVOID cCipherText = NULL;
		DWORD dwCipherSize = NULL;

		//Debugging
		printf("Data: %s \n\n", Data);

		//Encrypting
		if (!SimpleEncryption(Data, sizeof(Data), pKey, pIv, &pCipherText, &dwCipherSize)) {
			return -1;
		}

		// Print encrypted buffer as hex array
		PrintHexData("CipherText", pCipherText, dwCipherSize)

			//freeing
		HeapFree(GetProcessHeap(), 0, pCipherText);
		system("PAUSE");
		return 0;
	}